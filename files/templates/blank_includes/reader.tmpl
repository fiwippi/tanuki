{{ define "title" }}Home{{ end }}

{{ define "styles" }}
<style>
    .dark body, .dark .container {
        background: black;
    }

    body, .container {
        background: white;
    }

    .container {
        overflow: visible;
        grid-template-columns: auto minmax(450px, 900px) auto;
    }

    /* Extra attributes added to .container for paged viewer */
    .pagedContainerExtra {
        grid-template-rows: 3vh 1fr 3vh;
        grid-template-areas:
                "lblank header rblank"
                "lblank main rblank"
                "lblank footer rblank";
        padding-bottom: 0;
        margin: 0;
    }
    /* Extra attributes added to .body for paged viewer */
    .pagedBodyExtra {
        padding-bottom: 0;
        margin: 0;
    }

    .scrollImg {
        width: 100%;
        height: auto;
    }

    .pagedImg {
        width: auto;
        height: 100%;
    }

    img {
        background: white;
        user-select: none;
    }

    .unloaded {
        border: 3px solid black;
        aspect-ratio: 2/3;
    }

    .pagedContainer {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        height: 94vh;
    }

    .scrollContainer {
        display: flex;
        flex-direction: column;
        align-items: center;
        row-gap: 40px;
    }
</style>
{{ end }}

{{ define "scripts" }}
<script defer src='{{versioning "/static/js/intersect.js"}}'></script>
<script src='{{versioning "/static/js/api.js"}}'></script>
<script src='{{versioning "/static/js/common.js"}}'></script>
<script>
    const blankImage = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
    const modeList = [
        {name: 'Continuous', value: 'continuous'},
        {name: 'Paged (Right-to-Left)', value: 'paged-rl'},
        {name: 'Paged (Left-to-Right)', value: 'paged-lr'}
    ]

    // https://stackoverflow.com/a/54000580
    function isEventInElement(event, element)   {
        let rect = element.getBoundingClientRect();
        let x = event.clientX;
        if (x < rect.left || x >= rect.right) return false;
        let y = event.clientY;
        if (y < rect.top || y >= rect.bottom) return false;
        return true;
    }

    document.addEventListener('alpine:init', () => {
        Alpine.data('reader', () => ({
            // General Data
            sid: {{ sid . }},
            eid: {{ eid . }},
            entry: {{ entry . }},
            initialProgress: {{ entryProgress . }},

            // Reader data
            images: [],

            // Reader Settings
            mode: localStorage.getItem('mode') || 'continuous', // 'continuous', 'paged-rl', 'paged-lr'

            // Progress EntriesMetadata
            currentPage: 1,
            lastSavedPage: 1,
            acceptUpdates: false,

            // Modal EntriesMetadata
            showModal: false,
            selectedPage: 1,
            selectedMode: "mode",
            selectedEntry: "",
            entries: {{ entries . }},
            entryIndex: -1,
            hasNextEntry: false,
            hasPreviousEntry: false,

            //
            get filteredEntries() {
                // Remove the current entry
                let temp = this.entries.filter(i => i.hash !== this.eid)
                // Prepend the entry so users can't change to it
                let front = this.entries.filter(i => i.hash === this.eid)
                temp.unshift(front[0])
                return temp
            },

            get filteredPages() {
                let temp = Array.from({length: this.entry.pages}, (_, i) => i + 1).filter(i => i !== this.currentPage)
                temp.unshift(this.currentPage)
                return temp
            },

            get filteredMode() {
                let temp = modeList.filter(i => i.value !== this.mode)
                let first = modeList.filter(i => i.value === this.mode)
                temp.unshift(first[0])
                return temp
            },

            async init() {
                // Start at the specific page if specified, otherwise start
                // at the user's last progress
                let specifiedPage = new URLSearchParams(window.location.search).get('page')
                if (specifiedPage === null || specifiedPage === undefined) {
                    this.currentPage = this.initialProgress.current
                } else {
                    this.currentPage = Math.max(Number(specifiedPage), 1)
                }
                this.lastSavedPage = this.currentPage

                // Determine which buttons can be displayed
                this.entryIndex = this.entries.findIndex((e) => e.hash === this.eid)
                if (this.entryIndex + 1 < this.entries.length) {
                    this.hasNextEntry = true
                }
                if (this.entryIndex - 1 >= 0) {
                    this.hasPreviousEntry = true
                }

                // Load the images
                this.images = new Array(this.entry.pages)

                // If we don't do this x-intersect triggers a new
                // update progress event before we can navigate to
                // the current page
                this.acceptUpdates = true

                // Ensure the mode is saved, jumpToPage triggers here
                this.changeMode(this.mode)
         },

            async loadEntry() {
                let resp = await apiGetEntry(this.sid, this.eid)

                if (resp === undefined || !resp.success) {
                    return false
                } else {
                    this.entry = resp.data
                    return true
                }
            },

            async getPage(num, buffer) {
                // Ensure valid page num
                if (num < 1 || num > this.entry.pages) {
                    console.error("page out of reach", num)
                    return
                }

                // Don't fetch page if already loaded
                if (this.images[num - 1] === undefined) {
                    // Fetch the image
                    let img = new Image()
                    let p =  waitUntilLoad(img)
                    img.src = '/api/series/{0}/entries/{1}/page/{2}'.format(this.sid, this.eid, num)
                    let success = await p
                        .then(() => { return true })
                        .catch(err => {console.log("failed to load image", num, err); return false})
                    // Set the img if loaded properly
                    if (success) {
                        this.images[num - 1] = img
                    }
                } else {
                    console.debug("page already loaded", num)
                }

                // If scrolling we need to load the image onto the placeholder,
                // we do this outside the image fetching because there are cases
                // the image have already been fetched (.e.g with the paged reader)
                // but we haven't bound their src to the continuous pages src.
                // This way ensures binding always happens.
                if (this.mode === 'continuous') {
                    document.getElementById(`page-${num}`).src = this.images[num - 1].src
                    document.getElementById(`page-${num}`).classList.remove("unloaded")
                }

                // Regardless of whether the image is already loaded, attempt to buffer 3 images ahead
                // we only want the viewport changing to trigger buffering because otherwise we will
                // start recursion and load all images possible
                if (buffer) {
                    // User could be scrolling up or down
                    await this.getPage(num - 1, false)
                    await this.getPage(num - 2, false)
                    await this.getPage(num - 3, false)

                    await this.getPage(num + 1, false)
                    await this.getPage(num + 2, false)
                    await this.getPage(num + 3, false)
                }
            },

            async jumpToPage(num) {
                // If called from the modal, num is a string,
                // so we need to ensure it is parsed as a number
                num = Number(num)
                // We might be changing because of the modal
                // and if so we don't want to see it
                this.showModal = false
                // Don't want to jump to pages which are out of range
                if (num < 1 || num > this.entry.pages) {
                    console.error("page out of reach", num)
                    return
                }

                if (this.mode === 'continuous') {
                    document.getElementById(`page-${num}`).scrollIntoView(true);
                } else {
                    // Manually call get page since we can't user x-intersect
                    await this.getPage(num, true)
                    this.$nextTick(() => {
                        this.$refs.page.src = this.images[num - 1].src
                        this.$refs.page.classList.remove("unloaded")
                    })
                }

                // Checks whether we need to update the page progress
                await this.updateProgress(num)
            },

            changeMode(mode) {
                // Set the mode
                this.mode = mode
                localStorage.setItem('mode', mode)

                // Change styling according to the mode
                if (this.mode === 'continuous') {
                    document.body.classList.remove('pagedBodyExtra')
                    document.getElementById('container').classList.remove('pagedContainerExtra')
                } else {
                    document.body.classList.add('pagedBodyExtra')
                    document.getElementById('container').classList.add('pagedContainerExtra')
                }

                // Wait for alpine to update the page layout before jumping
                this.$nextTick(() => {
                    this.jumpToPage(this.currentPage)
                })
            },

            changeEntry(eid) {
                let url = '/reader/{0}/{1}'.format(this.sid, eid)
                window.location.replace(url)
            },

            exitReader() {
                let url = '/entries/{0}'.format(this.sid)
                window.location.replace(url)
            },

            async updateProgress(num) {
                if (!this.acceptUpdates) {
                    return
                }

                this.currentPage = num

                let a = this.currentPage === 1
                let b = this.currentPage === this.entry.pages
                let c = Math.abs(this.lastSavedPage - this.currentPage) >= 5

                if (a || b || c) {
                    this.lastSavedPage = this.currentPage
                    let resp = await apiPatchUserProgress(this.sid, this.eid, this.currentPage.toString())
                    if (!resp) {
                        console.error('failed to set progress for entry')
                    }
                }
            },

            async flipPage(direction) {
                if (this.mode === 'paged-lr') {
                    if (direction === 'left') await this.jumpToPage(this.currentPage - 1)
                    if (direction === 'right') await this.jumpToPage(this.currentPage + 1)
                } else if (this.mode === 'paged-rl') {
                    if (direction === 'left') await this.jumpToPage(this.currentPage + 1)
                    if (direction === 'right') await this.jumpToPage(this.currentPage - 1)
                }
            },

            async handlePagedClick(e) {
                let mouseX = e.clientX
                let width = document.body.clientWidth
                let percent = mouseX / width

                // Click in the left 40% means go left
                if (!this.showModal && percent < 0.4) {
                    await this.flipPage("left")
                }

                // Click in the centre 20% and click on the page means show the modal
                if (!this.showModal && isEventInElement(e, this.$refs.page) && percent >= 0.4 && percent <= 0.6) {
                    this.showModal = true
                }

                // Click in the right 40% means go right
                if (!this.showModal && percent > 0.6) {
                    await this.flipPage("right")
                }

            }
        }))
    })
</script>
{{ end }}

{{ define "content" }}
<div x-data="reader">
    <!--  Modal  -->
    <div x-cloak>
        <div  x-show="showModal" class="modal">
            <div @click.away="showModal = false" x-show="showModal" x-transition class="modal-content">
                <span class="close" @click="showModal = false">&times;</span>
                <h2 x-text="entry.title" style="margin-block-end: 0.2em"></h2>
                <p x-text="entry.path" style="margin-block-start: 0.5em"></p>

                <h4 style="margin-block-end: 0.2em">Progress</h4>
                <p x-text="'{0}/{1} ({2})'.format(currentPage, entry.pages, stringPercent((currentPage / entry.pages) * 100))"
                   style="margin-block-start: 0.1em"></p>

                <h4 style="margin-block-end: 0.2em">Jump To Page</h4>
                <select x-model="selectedPage" @change="await jumpToPage(selectedPage)">
                    <template x-for="i in filteredPages">
                        <option :value="i" x-text="i"></option>
                    </template>
                </select>

                <h4 style="margin-block-end: 0.2em">Mode</h4>
                <select x-model="selectedMode" @change="changeMode(selectedMode)">
                    <template x-for="m in filteredMode">
                        <option :value="m.value" x-text="m.name"></option>
                    </template>
                </select>

                <h4 style="margin-block-end: 0.2em">Jump To Entry</h4>
                <select x-model="selectedEntry" @change="changeEntry(selectedEntry)">
                    <template x-for="e in filteredEntries">
                        <option :value="e.hash" x-text="e.title"></option>
                    </template>
                </select>

                <div class="flex_div" style="column-gap: 10px; margin-top: 30px; justify-content: flex-end">
                    <button @click="changeEntry(entries[entryIndex - 1].hash)" x-show="hasPreviousEntry">Previous Entry</button>
                    <button @click="changeEntry(entries[entryIndex + 1].hash)" x-show="hasNextEntry">Next Entry</button>
                    <button @click="exitReader()">Exit Reader</button>
                </div>

            </div>
        </div>
    </div>

    <!--  Paged reader  -->
    <template x-if="mode !==  'continuous'">
        <div class="pagedContainer" @click.document="await handlePagedClick">
            <img class="unloaded pagedImg" :src="blankImage" x-ref="page">

            <!--  Configures key events for scrolling direction  -->
            <div style="display: none"
                 @keydown.arrow-left.document="await flipPage('left')"
                 @keydown.arrow-right.document="await flipPage('right')">
            </div>
        </div>
    </template>

    <!--  Continuous scrolling reader  -->
    <template x-if="mode ===  'continuous'">
        <div class="scrollContainer">
            <template x-for="i in entry.pages">
                <img class="unloaded scrollImg" :src="blankImage" :id="`page-${i}`" x-intersect.once="await getPage(i, true)"
                     x-intersect="await updateProgress(i)" @click="showModal = true">
            </template>
            <button @click="changeEntry(entries[entryIndex + 1].hash)" x-show="hasNextEntry">Next Entry</button>
            <button @click="exitReader()" x-show="!hasNextEntry">Exit Reader</button>
        </div>

    </template>
</div>
{{ end }}